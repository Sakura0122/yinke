# js高阶用法

## 原型 & 原型链

```js
function Person() {}

Person.prototype.name = 'sakura'
const person1 = new Person()
const person2 = new Person()

console.log(person1.name)
console.log(person2.name)
```
原型：任何一个js对象中创建时会关联的一个对象 任何一个根据原型的构造函数创造出来的对象 都会继承原型上的属性

```js
function Person() {}
const person = new Person()
console.log(person.__proto__ === Person.prototype)
console.log(Person === Person.prototype.constructor)
console.log(Object.getPrototypeOf(person) === Person.prototype)
```

```js
function Person() {}
Person.prototype.name = 'sakura'

const person = new Person()
person.name = 'xzp'
console.log(person.name)

delete person.name
console.log(person.name)
```

```js
function Person() {}

const person = new Person()
console.log(person.constructor)
```

继承 任何对象 会从原型继承属性 委托

## 词法作用域 动态作用域

作用域 程序定义变量的区域 作用域中定义了如何找到对象的变量 再执行代码 运行在作用域中 获取对变量的访问权限

js词法作用域

静态作用域：作用域在定义时就确认
动态作用域：作用域是在调用时决定

```js
const value = 1
function foo() {
  console.log(this.value)
}

function bar() {
  const value = 2
  foo()
}

bar()
```

```js
// case1
var scope = 'sakura'
function foo() {
  var scope = 'xzp'
  function f() {
    return scope
  }
  return f()
}
foo()

// case2
var scope = 'sakura'
function foo() {
  var scope = 'xzp'
  function f() {
    return scope
  }
  return f
}
foo()()
```

## 执行上下文

```js
var foo = function () {
  console.log('foo1')
}
foo()

var foo = function () {
  console.log('foo2')
}
foo()
```

```js
function foo() {
  console.log('foo1')
}
foo()

function foo() {
  console.log('foo2')
}
foo()
```

### 可执行代码

executable code

全局代码 函数代码 eval

execution context 执行上下文

execution context stack ECS 执行上下文栈

ECSstack = [
    globalContext, // 全局上下文
]

```js
function foo3() {
  console.log('foo3')
}

function foo2() {
  foo3()
}

function foo1() {
  foo2()
}

foo1()
```

## 变量对象

execution context

1. 变量对象
2. 作用域链
3. this

variable object VO

在上下文 变量 或 函数的声明

全局上下文

```js
console.log(this) // window
a = 1
```

函数上下文

activation object AO

执行上下文

1.进入执行上下文
VO
函数的定义 声明 变量的声明 函数的形参 没有实际传入的参数 arguments undefined

```js
function foo(a) {
  var b = 2
  function c() {}
  var d = function () {}
  b = 3
}
foo(1)
```

AO = {
  arguments: {
    0: 1,
    length: 1
  }
  a: 1,
  b: undefined,
  c: reference to function c() {},
  d: undefined
}

2.执行

AO = {
  arguments: {
    0: 1,
    length: 1
  }
  a: 1,
  b: 2,
  c: reference to function c() {},
  d: reference to FunctionExpression d
}

```js
function foo() {
  console.log(a)
  a = 1
}
foo()

function bar() {
  a = 1
  console.log(a)
}
bar()
```


## 作用域链

找变量 先从当前上下文找 找不到从词法作用域的上一级找 直到找到全局上下文的变量对象为止

```js
[[scope]]
function foo() {
  function bar() {}
}

foo.[[scope]] = [
  globalContext.VO
]

bar.[[scope]] = [
  fooContext.AO,
  globalContext.VO
]

[bar AO].contact(...[
  fooContext.AO,
  globalContext.VO
])
```

### this

Reference 规范类型
1. base value 属性所在的对象
2. reference name
3. strict reference

```js
var foo = 1

fooReferece = {
  base: 'EnvironmentRecord',
  name: 'foo',
  strict: false
}

var foo = {
  bar: function () {
    return this
  }
}
foo.bar()
```

```js
var value = 1
var foo = {
  value: 2,
  bar: function () {
    return this.value
  }
}

console.log(foo.bar())
console.log((foo.bar)())
console.log((foo.bar = foo.bar)())
console.log((false || foo.bar)())
console.log((foo.bar, foo.bar)())
```

## 闭包

能够访问自由变量的函数

自由变量 函数中引用了函数外的变量

闭包 = 函数 + 能够访问函数外部的变量

```js
var a = 1
function foo() {
  console.log(a)
}
foo()
```
